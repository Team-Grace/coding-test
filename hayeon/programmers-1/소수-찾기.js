function solution(n) {
  const nArr = new Array(n).fill(1);

  nArr[0] = 0;

  for (let i = 2; i * i <= n; i++) {
    for (let j = i * i; j <= n; j += i) {
      nArr[j - 1] = 0;
    }
  }
  return nArr.filter((result) => result == 1).length;
}

/** 풀이
 처음에 소수찾는 법도 몰라서 구글링해서 소수찾는 법을 알아냈다.
 소수찾는법을 알아내서 코드를 구현했는데 답이 계속 안나와서 구글링을 통해 여러 곳 풀이를 읽었지만
 아직도 잘 모르겠다...... 너무 어렵다 ㅠㅠ
 위 풀이의 방식은 n개수 만큼의 배열을 만들어 1로 채워놓고
 1은 소수가 아니니 처음에 배열[0]을 0으로 변경해준 것
 2부터 제곱근으로 순회해 2의 배수들을 모두 0으로 변경하고,
 다시 3으로 순회할 경우 3의 배수들을 0으로 바꿔주는 것이다.
 결국 소수들은 1로 남게 될 것이고, filter함수로 1인 값만 반환해 개수를 알아낼 수 있었다.
 이 풀이 방식도 아직은 어렵지만 .. 헤쳐나가야할 문제인 것!!
 다시 뜯어보고 공부해봐야겠다.
 "제곱근으로 순회한다." 는 말은 아직도 어려운 것 같다.
 */
